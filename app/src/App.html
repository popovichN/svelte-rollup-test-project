<h1>Line chart</h1>

<svg>
{{#if ready}}
	<g transform='translate(0,0)'>
		<g class='axes'>
			<!-- y axis -->
			<g class='axis y-axis' transform="translate(0, {{ padding.top }} )">
				<!-- <path stroke="#000" d=""></path> -->
				{{#each yTicks as tick}}
					<g class="tick tick-{{ tick }}" transform="translate( 0, {{ yScale(tick) - padding.bottom }} )">
						<line stroke="#000" x2="100%" y1="0" y2="0"></line>
						<text fill="#000" x="0" y="0" dy="-2">{{ tick !== 0 ? tick : ''}}</text>
					</g>
				{{/each}}
			</g>
			<!-- x axis -->
			<g class='axis x-axis'>
				{{#each xTicks as tick}}
					<g class="tick tick-{{ tick }}" transform="translate( {{ xScale(tick) }}, {{ height }} )">
						<!-- <line stroke="#000" x2="100%" y1="0" y2="0"></line> -->
						<text fill="#000" x="0" y="0" dy="-2">{{ tick !== 0 ? tick : ''}}</text>
					</g>
				{{/each}}
			</g>
		</g>
	</g>

	<path class='path-line' d="{{ path }}"></path>
{{/if}}
</svg>

<Nested foo='{{foo}}'/>

<style>
	svg {
		width: 300px;
		height: 0;
		padding-bottom: 50%;
	}
	.tick {
		font-family: Arial;
		font-size: .825em;
	}
	.tick line {
		stroke: #e2e2e2;
		stroke-dasharray: 2;
	}
	.tick text {
		fill: #ccc;
		text-anchor: start;
	}
	.tick.tick-0 line {
		stroke-dasharray: 0;
	}
	.x-axis .tick text {
		text-anchor: middle;
	}
	.path-line {
		fill: none;
		stroke: #fb0;
		stroke-linejoin: round;
		stroke-linecap: round;
		stroke-width: 1.5; 
	}
</style>

<script>
	import Nested from './Nested.html';
	import { scaleLinear } from "d3-scale";

	export default {
		data () {
			return {
				padding: {
					top: 20,
					right: 15,
					bottom: 20,
					left: 25
				},
				height: 200,
				width: 300,
				foo: 'bar',
				yTicks:  [0, 5, 10, 15, 20 ],
				xTicks: [1990, 1995, 2000, 2005, 2010, 2015],
				projects: [],
				ready: false
			};
		},
		components: {
			Nested
		},
		computed: {
			yScale: function ( padding, height, yTicks ) {
				return scaleLinear()
					.domain([Math.min.apply(null, yTicks), Math.max.apply(null, yTicks)])
   					.range([height - padding.bottom, padding.top]);
			},
			xScale: function ( padding, width, xTicks ) {
				return scaleLinear()
					.domain([Math.min.apply(null, xTicks), Math.max.apply(null, xTicks)])
   					.range([padding.left, width - padding.right]);
			},
			path ( projects, xScale, yScale ) {
				
				var path = '';

				// make path
				projects.forEach(function (datapoint, i) {
					var year = datapoint.year;

					if (i === 0) {
						path = 'M' + xScale(year) + ' ' + yScale(datapoint.birthrate_all) + ' ';
					} else {
						path += 'L ' + xScale(year) + ' ' + yScale(datapoint.birthrate_all) + ' ';

					}
				})
			
				return path;
			}
		},
		onrender () {
			console.log('rendered')
		}

	};

	(function () {
		  var xhttp = new XMLHttpRequest();
		  xhttp.onreadystatechange = function() {
		    if (this.readyState == 4 && this.status == 200) {
		    	var projects = JSON.parse(this.responseText);

		    	//pass data to Svelte app
		    	app.set({ projects, ready: true })
		    }
		  };
		  xhttp.open("GET", './data/births_by_race.json', true);
		  xhttp.send();
	})();
</script>
